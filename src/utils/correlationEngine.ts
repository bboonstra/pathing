import { v4 as uuidv4 } from "uuid";
import { EventData, WidgetConfig } from "@/types/widgets";
import { createWidget } from "./widgetFactory";

/**
 * Analyzes event data for correlations between different event types and properties
 */
export function analyzeCorrelations(events: EventData[]): WidgetConfig[] {
    const correlationInsights: WidgetConfig[] = [];

    // Only analyze if we have enough data
    if (events.length < 20) {
        return correlationInsights;
    }

    // Find user journey correlations (sequence of page visits)
    const journeyInsight = analyzeUserJourneys(events);
    if (journeyInsight) correlationInsights.push(journeyInsight);

    // Find correlations between referrers and conversions
    const referrerConversionInsight = analyzeReferrerConversions(events);
    if (referrerConversionInsight)
        correlationInsights.push(referrerConversionInsight);

    // Find time-based patterns (e.g., day of week, time of day impact)
    const timePatternInsight = analyzeTimePatterns(events);
    if (timePatternInsight) correlationInsights.push(timePatternInsight);

    // Find correlations between page attributes and user behavior
    const pageAttributeInsight = analyzePageAttributes(events);
    if (pageAttributeInsight) correlationInsights.push(pageAttributeInsight);

    // Find cohort retention patterns
    const cohortRetentionInsight = analyzeCohortRetention(events);
    if (cohortRetentionInsight)
        correlationInsights.push(cohortRetentionInsight);

    // Analyze feature impact on conversion
    const featureImpactInsight = analyzeFeatureImpact(events);
    if (featureImpactInsight) correlationInsights.push(featureImpactInsight);

    return correlationInsights;
}

/**
 * Analyzes common user journeys through the site
 */
function analyzeUserJourneys(events: EventData[]): WidgetConfig | null {
    // Group events by user if possible (e.g., session ID or user ID)
    const sessionEvents: Record<string, EventData[]> = {};

    events.forEach((event) => {
        // Use some identifier from the event to group by user session
        // This could be a cookie, IP, user ID, etc.
        const sessionId = (event.payload?.session_id ||
            event.payload?.user_id ||
            `${event.payload?.ip}-${new Date(
                event.created_at
            ).toDateString()}`) as string;

        if (!sessionId) return;

        if (!sessionEvents[sessionId]) {
            sessionEvents[sessionId] = [];
        }

        sessionEvents[sessionId].push(event);
    });

    // Need at least a few sessions to analyze
    if (Object.keys(sessionEvents).length < 5) {
        return null;
    }

    // Sort each session's events by timestamp
    Object.values(sessionEvents).forEach((sessionEvts) => {
        sessionEvts.sort(
            (a, b) =>
                new Date(a.created_at).getTime() -
                new Date(b.created_at).getTime()
        );
    });

    // Extract paths from each session to find common journeys
    const journeys: string[][] = [];
    Object.values(sessionEvents).forEach((sessionEvts) => {
        const journey = sessionEvts
            .filter((e) => e.payload?.path)
            .map((e) => e.payload?.path as string);

        if (journey.length >= 2) {
            journeys.push(journey);
        }
    });

    // Need at least a few journeys to analyze
    if (journeys.length < 3) {
        return null;
    }

    // Find common paths (simple implementation - could be more sophisticated)
    const pathPairs: Record<string, number> = {};
    journeys.forEach((journey) => {
        for (let i = 0; i < journey.length - 1; i++) {
            const pair = `${journey[i]} â†’ ${journey[i + 1]}`;
            pathPairs[pair] = (pathPairs[pair] || 0) + 1;
        }
    });

    // Sort by frequency
    const sortedPairs = Object.entries(pathPairs)
        .sort(([, countA], [, countB]) => countB - countA)
        .slice(0, 5);

    // Only create insight if we found common patterns
    if (sortedPairs.length === 0 || sortedPairs[0][1] < 3) {
        return null;
    }

    return createWidget(
        "customInsight",
        "User Journey Patterns",
        { i: `insight-${uuidv4()}`, x: 0, y: 0, w: 2, h: 2 },
        {
            insightType: "userJourney",
            journeyData: sortedPairs,
            isAutoGenerated: true,
            description: "Common paths users take through your site",
            timeFrame: "7d",
            displayOptions: {
                chartType: "flow",
            },
        }
    );
}

/**
 * Analyzes correlations between referrers and conversions
 */
function analyzeReferrerConversions(events: EventData[]): WidgetConfig | null {
    // Get conversion events
    const conversionEvents = events.filter(
        (e) =>
            e.type &&
            (e.type === "conversion" ||
                e.type.includes("purchase") ||
                e.type.includes("signup"))
    );

    // Need enough conversions to analyze
    if (conversionEvents.length < 5) {
        return null;
    }

    // Group events by session to track referrers that led to conversions
    const sessionEvents: Record<string, EventData[]> = {};

    events.forEach((event) => {
        const sessionId = (event.payload?.session_id ||
            event.payload?.user_id ||
            `${event.payload?.ip}-${new Date(
                event.created_at
            ).toDateString()}`) as string;

        if (!sessionId) return;

        if (!sessionEvents[sessionId]) {
            sessionEvents[sessionId] = [];
        }

        sessionEvents[sessionId].push(event);
    });

    // Analyze referrers that led to conversions
    const referrerConversions: Record<
        string,
        { count: number; total: number }
    > = {};

    Object.values(sessionEvents).forEach((sessionEvts) => {
        // Sort by timestamp
        sessionEvts.sort(
            (a, b) =>
                new Date(a.created_at).getTime() -
                new Date(b.created_at).getTime()
        );

        // Check if session had a conversion
        const hasConversion = sessionEvts.some(
            (e) =>
                e.type &&
                (e.type === "conversion" ||
                    e.type.includes("purchase") ||
                    e.type.includes("signup"))
        );

        // Get the first referrer in the session
        const firstEvent = sessionEvts[0];
        const referrer = firstEvent?.payload?.referrer || "direct";

        // Track referrer conversion rate
        if (!referrerConversions[referrer]) {
            referrerConversions[referrer] = { count: 0, total: 0 };
        }

        referrerConversions[referrer].total++;

        if (hasConversion) {
            referrerConversions[referrer].count++;
        }
    });

    // Calculate conversion rates and sort
    const conversionRates = Object.entries(referrerConversions)
        .filter(([, stats]) => stats.total >= 3) // Only include referrers with enough data
        .map(([referrer, stats]) => ({
            referrer,
            conversionRate: stats.count / stats.total,
            count: stats.count,
            total: stats.total,
        }))
        .sort((a, b) => b.conversionRate - a.conversionRate);

    // Only create insight if we have meaningful data
    if (conversionRates.length < 2) {
        return null;
    }

    return createWidget(
        "customInsight",
        "Referrer Conversion Impact",
        { i: `insight-${uuidv4()}`, x: 0, y: 0, w: 2, h: 2 },
        {
            insightType: "referrerConversion",
            conversionData: conversionRates,
            isAutoGenerated: true,
            description:
                "How different traffic sources affect conversion rates",
            displayOptions: {
                chartType: "bar",
            },
        }
    );
}

/**
 * Analyzes time-based patterns in event data
 */
function analyzeTimePatterns(events: EventData[]): WidgetConfig | null {
    // Need enough events to analyze
    if (events.length < 30) {
        return null;
    }

    // Analyze events by day of week
    const dayOfWeekCounts: number[] = [0, 0, 0, 0, 0, 0, 0]; // Sun-Sat
    const hourCounts: number[] = Array(24).fill(0);

    events.forEach((event) => {
        const date = new Date(event.created_at);
        const dayOfWeek = date.getDay(); // 0-6
        const hour = date.getHours(); // 0-23

        dayOfWeekCounts[dayOfWeek]++;
        hourCounts[hour]++;
    });

    // Calculate daily averages
    const eventsByDay: Record<string, number> = {};
    events.forEach((event) => {
        const day = new Date(event.created_at).toISOString().split("T")[0];
        eventsByDay[day] = (eventsByDay[day] || 0) + 1;
    });

    const dailyActivityAvg =
        Object.values(eventsByDay).reduce((sum, count) => sum + count, 0) /
        Object.keys(eventsByDay).length;

    // Find peak times (days and hours)
    const peakDayIndex = dayOfWeekCounts.indexOf(Math.max(...dayOfWeekCounts));
    const peakHourIndex = hourCounts.indexOf(Math.max(...hourCounts));

    // Map day index to name
    const days = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    ];
    const peakDay = days[peakDayIndex];

    // Format hour with AM/PM
    const formatHour = (hour: number) => {
        if (hour === 0) return "12 AM";
        if (hour === 12) return "12 PM";
        return hour < 12 ? `${hour} AM` : `${hour - 12} PM`;
    };

    const peakHour = formatHour(peakHourIndex);

    // Detect if there's a significant pattern
    const dayVariance = calculateVariance(dayOfWeekCounts);
    const hourVariance = calculateVariance(hourCounts);

    // Only create insight if we found meaningful patterns
    const hasDayPattern = dayVariance / dailyActivityAvg > 0.2;
    const hasHourPattern = hourVariance / dailyActivityAvg > 0.3;

    if (!hasDayPattern && !hasHourPattern) {
        return null;
    }

    return createWidget(
        "customInsight",
        "Activity Time Patterns",
        { i: `insight-${uuidv4()}`, x: 0, y: 0, w: 2, h: 2 },
        {
            insightType: "timePattern",
            timeData: {
                dayOfWeekCounts,
                hourCounts,
                peakDay,
                peakHour,
            },
            isAutoGenerated: true,
            description: `Peak activity detected on ${peakDay}s around ${peakHour}`,
            displayOptions: {
                chartType: "heatmap",
            },
        }
    );
}

/**
 * Analyzes correlations between page attributes and user behavior
 */
function analyzePageAttributes(events: EventData[]): WidgetConfig | null {
    // Group events by page path
    const pageEvents: Record<string, EventData[]> = {};

    events.forEach((event) => {
        const path = event.payload?.path;
        if (!path) return;

        if (!pageEvents[path]) {
            pageEvents[path] = [];
        }

        pageEvents[path].push(event);
    });

    // Need enough pages to analyze
    if (Object.keys(pageEvents).length < 3) {
        return null;
    }

    // Calculate metrics for each page
    const pageMetrics = Object.entries(pageEvents).map(([path, evts]) => {
        // Time spent calculation (if events contain enter/exit timestamps)
        const avgTimeSpent = 0;
        const bounceRate = 0;

        // If we have user/session identifiers, we can calculate more metrics
        const uniqueVisitors = new Set();
        evts.forEach((evt) => {
            const visitorId =
                evt.payload?.user_id ||
                evt.payload?.session_id ||
                evt.payload?.ip;
            if (visitorId) uniqueVisitors.add(visitorId);
        });

        return {
            path,
            eventCount: evts.length,
            uniqueVisitors: uniqueVisitors.size,
            avgTimeSpent,
            bounceRate,
        };
    });

    // Sort by event count
    pageMetrics.sort((a, b) => b.eventCount - a.eventCount);

    // Check for patterns in the page metrics
    const hasValidData =
        pageMetrics.length >= 3 &&
        pageMetrics[0].eventCount >= 10 &&
        pageMetrics[0].uniqueVisitors >= 5;

    if (!hasValidData) {
        return null;
    }

    // Normalize paths to extract common patterns
    const pathTypes = extractPathTypes(pageMetrics.map((pm) => pm.path));

    return createWidget(
        "customInsight",
        "Page Performance Patterns",
        { i: `insight-${uuidv4()}`, x: 0, y: 0, w: 2, h: 2 },
        {
            insightType: "pagePerformance",
            pageData: pageMetrics.slice(0, 10),
            pathTypes,
            isAutoGenerated: true,
            description:
                "How different page types perform based on visitor activity",
            displayOptions: {
                chartType: "bar",
            },
        }
    );
}

/**
 * Analyzes cohort retention over time
 * Tracks how users who started in a given week continue to use the site over subsequent weeks
 */
function analyzeCohortRetention(events: EventData[]): WidgetConfig | null {
    // Need enough events for meaningful cohort analysis
    if (events.length < 100) {
        return null;
    }

    // Group events by user
    const userEvents: Record<string, EventData[]> = {};
    events.forEach((event) => {
        const userId = event.payload?.user_id || event.payload?.session_id;
        if (!userId || typeof userId !== "string") return;

        if (!userEvents[userId]) {
            userEvents[userId] = [];
        }
        userEvents[userId].push(event);
    });

    // Need enough users to analyze
    if (Object.keys(userEvents).length < 20) {
        return null;
    }

    // Find first activity date for each user
    const userFirstActivity: Record<string, Date> = {};
    Object.entries(userEvents).forEach(([userId, userEvts]) => {
        const dates = userEvts.map((e) => new Date(e.created_at));
        dates.sort((a, b) => a.getTime() - b.getTime());
        userFirstActivity[userId] = dates[0];
    });

    // Group users into weekly cohorts
    const getWeekKey = (date: Date) => {
        // Format as YYYY-WW (year and week number)
        const year = date.getFullYear();
        // Get the ISO week number
        const weekNum = getISOWeek(date);
        return `${year}-W${weekNum.toString().padStart(2, "0")}`;
    };

    // Track which weeks each user was active
    const userActivityByWeek: Record<string, Set<string>> = {};
    Object.entries(userEvents).forEach(([userId, userEvts]) => {
        userActivityByWeek[userId] = new Set();
        userEvts.forEach((event) => {
            const weekKey = getWeekKey(new Date(event.created_at));
            userActivityByWeek[userId].add(weekKey);
        });
    });

    // Group users by cohort (first activity week)
    const cohorts: Record<string, string[]> = {};
    Object.entries(userFirstActivity).forEach(([userId, firstDate]) => {
        const cohortKey = getWeekKey(firstDate);
        if (!cohorts[cohortKey]) {
            cohorts[cohortKey] = [];
        }
        cohorts[cohortKey].push(userId);
    });

    // Calculate retention for each cohort
    const cohortsWithEnoughUsers = Object.entries(cohorts)
        .filter(([, userIds]) => userIds.length >= 5)
        .map(([cohortKey, userIds]) => ({ cohortKey, userIds }));

    // Only continue if we have enough cohorts
    if (cohortsWithEnoughUsers.length < 2) {
        return null;
    }

    // Get all week keys in chronological order
    const allWeekKeys = Array.from(
        new Set(
            Object.values(userActivityByWeek)
                .flatMap((weeks) => Array.from(weeks))
                .sort()
        )
    );

    // For each cohort, calculate retention rates for subsequent weeks
    const retentionData = cohortsWithEnoughUsers.map(
        ({ cohortKey, userIds }) => {
            const cohortSize = userIds.length;
            const retentionByWeek: Record<string, number> = {};

            // Calculate retention for each week
            allWeekKeys.forEach((weekKey) => {
                if (weekKey < cohortKey) return; // Skip weeks before cohort started

                // Count users active in this week
                const activeUsers = userIds.filter((userId) =>
                    userActivityByWeek[userId]?.has(weekKey)
                ).length;

                retentionByWeek[weekKey] = (activeUsers / cohortSize) * 100;
            });

            return {
                cohort: cohortKey,
                size: cohortSize,
                retention: retentionByWeek,
            };
        }
    );

    return createWidget(
        "customInsight",
        "User Cohort Retention",
        { i: `insight-${uuidv4()}`, x: 0, y: 0, w: 3, h: 2 },
        {
            insightType: "cohortRetention",
            retentionData,
            weekKeys: allWeekKeys,
            isAutoGenerated: true,
            description: "How well you're retaining users over time by cohort",
            displayOptions: {
                chartType: "heatmap",
                showLabels: true,
            },
        }
    );
}

/**
 * Analyzes which features or elements on the site have the most impact on conversions
 */
function analyzeFeatureImpact(events: EventData[]): WidgetConfig | null {
    // Need enough events for meaningful analysis
    if (events.length < 100) {
        return null;
    }

    // Group events by session
    const sessionEvents: Record<string, EventData[]> = {};
    events.forEach((event) => {
        const userIdValue = event.payload?.user_id;
        const ipValue = event.payload?.ip;
        const sessionIdValue = event.payload?.session_id;

        let sessionId: string;
        if (typeof sessionIdValue === "string") {
            sessionId = sessionIdValue;
        } else if (
            typeof userIdValue === "string" ||
            typeof ipValue === "string"
        ) {
            const userOrIp =
                typeof userIdValue === "string"
                    ? userIdValue
                    : (ipValue as string);
            sessionId = `${userOrIp}-${new Date(
                event.created_at
            ).toDateString()}`;
        } else {
            return; // Skip if we can't determine a session ID
        }

        if (!sessionEvents[sessionId]) {
            sessionEvents[sessionId] = [];
        }

        sessionEvents[sessionId].push(event);
    });

    // Need enough sessions to analyze
    if (Object.keys(sessionEvents).length < 20) {
        return null;
    }

    // Identify important features/interactions from events
    const featureInteractions: Set<string> = new Set();
    Object.values(sessionEvents).forEach((sessionEvts) => {
        sessionEvts.forEach((event) => {
            if (
                typeof event.type === "string" &&
                (event.type.includes("click") ||
                    event.type.includes("interact"))
            ) {
                const elementId = event.payload?.element_id;
                const elementClass = event.payload?.element_class;
                const element =
                    typeof elementId === "string"
                        ? elementId
                        : typeof elementClass === "string"
                        ? elementClass
                        : null;

                if (element) featureInteractions.add(element);
            }
        });
    });

    // For each feature, check correlation with conversion
    const featureImpact: Record<
        string,
        {
            used: number;
            converted: number;
            conversionRate: number;
            impact: number;
        }
    > = {};

    // Calculate baseline conversion rate
    const totalSessions = Object.keys(sessionEvents).length;
    const convertedSessions = Object.values(sessionEvents).filter(
        (sessionEvts) =>
            sessionEvts.some((e) => {
                if (typeof e.type !== "string") return false;
                return (
                    e.type === "conversion" ||
                    e.type.includes("purchase") ||
                    e.type.includes("signup")
                );
            })
    ).length;

    const baselineConversionRate = convertedSessions / totalSessions;

    // Analyze impact of each feature
    Array.from(featureInteractions).forEach((feature) => {
        // Count sessions that used this feature
        const sessionsWithFeature = Object.entries(sessionEvents).filter(
            ([, sessionEvts]) =>
                sessionEvts.some((e) => {
                    const elementId = e.payload?.element_id;
                    const elementClass = e.payload?.element_class;
                    const element =
                        typeof elementId === "string"
                            ? elementId
                            : typeof elementClass === "string"
                            ? elementClass
                            : null;
                    return element === feature;
                })
        );

        const featureUsageCount = sessionsWithFeature.length;

        // Skip features with low usage
        if (featureUsageCount < 5 || featureUsageCount / totalSessions < 0.05) {
            return;
        }

        // Count conversions among sessions that used the feature
        const featureConversionCount = sessionsWithFeature.filter(
            ([, sessionEvts]) =>
                sessionEvts.some((e) => {
                    if (typeof e.type !== "string") return false;
                    return (
                        e.type === "conversion" ||
                        e.type.includes("purchase") ||
                        e.type.includes("signup")
                    );
                })
        ).length;

        const featureConversionRate =
            featureConversionCount / featureUsageCount;

        // Calculate lift compared to baseline
        const liftOverBaseline =
            featureConversionRate / baselineConversionRate - 1;

        featureImpact[feature] = {
            used: featureUsageCount,
            converted: featureConversionCount,
            conversionRate: featureConversionRate,
            impact: liftOverBaseline * 100, // as percentage
        };
    });

    // Sort features by impact
    const sortedFeatures = Object.entries(featureImpact)
        .sort(([, a], [, b]) => Math.abs(b.impact) - Math.abs(a.impact))
        .slice(0, 10)
        .map(([feature, stats]) => ({
            feature,
            ...stats,
        }));

    // Only create insight if we found meaningful patterns
    if (sortedFeatures.length < 3) {
        return null;
    }

    return createWidget(
        "customInsight",
        "Feature Impact on Conversion",
        { i: `insight-${uuidv4()}`, x: 0, y: 0, w: 3, h: 2 },
        {
            insightType: "featureImpact",
            featureData: sortedFeatures,
            baselineConversionRate,
            isAutoGenerated: true,
            description:
                "How different site features affect your conversion rates",
            displayOptions: {
                chartType: "bar",
                showLabels: true,
            },
        }
    );
}

/**
 * Extract meaningful path types from URLs
 */
function extractPathTypes(paths: string[]): Record<string, string[]> {
    const pathTypes: Record<string, string[]> = {
        product: [],
        category: [],
        article: [],
        landing: [],
        other: [],
    };

    paths.forEach((path) => {
        // Simple heuristic to categorize paths
        if (path.includes("/product/") || path.includes("/p/")) {
            pathTypes.product.push(path);
        } else if (
            path.includes("/category/") ||
            path.includes("/c/") ||
            path.includes("/collection/")
        ) {
            pathTypes.category.push(path);
        } else if (
            path.includes("/article/") ||
            path.includes("/blog/") ||
            path.includes("/post/")
        ) {
            pathTypes.article.push(path);
        } else if (
            path === "/" ||
            path.includes("/landing/") ||
            path.includes("/lp/")
        ) {
            pathTypes.landing.push(path);
        } else {
            pathTypes.other.push(path);
        }
    });

    return pathTypes;
}

/**
 * Calculate variance of a numeric array
 */
function calculateVariance(arr: number[]): number {
    const mean = arr.reduce((sum, val) => sum + val, 0) / arr.length;
    return (
        arr.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / arr.length
    );
}

/**
 * Get ISO week number of a date
 */
function getISOWeek(date: Date): number {
    const d = new Date(date);
    d.setHours(0, 0, 0, 0);
    d.setDate(d.getDate() + 4 - (d.getDay() || 7));
    const yearStart = new Date(d.getFullYear(), 0, 1);
    return Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);
}

const correlationEngine = {
    analyzeCorrelations,
};

export default correlationEngine;
