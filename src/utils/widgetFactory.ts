import { v4 as uuidv4 } from "uuid";
import {
    WidgetConfig,
    WidgetType,
    WidgetLayout,
    EventData,
    WidgetSettings,
} from "@/types/widgets";
import widgetRegistry from "./widgetRegistry";

/**
 * Creates a new widget configuration
 */
export function createWidget(
    type: WidgetType,
    title: string,
    layout?: Partial<WidgetLayout>,
    settings: Record<string, unknown> = {}
): WidgetConfig {
    const now = new Date().toISOString();
    const id = uuidv4();

    // Get widget definition from registry
    const widgetDefinition = widgetRegistry.getDefinition(type);

    // Use constraints from widget definition if available
    const constraints = widgetDefinition?.constraints;

    // Create layout with default constraints if available
    const defaultLayout: WidgetLayout = {
        i: `${type}-${id.substring(0, 8)}`,
        x: 0,
        y: 0,
        w: constraints?.defaultWidth || 2,
        h: constraints?.defaultHeight || 1,
        minW: constraints?.minWidth,
        maxW: constraints?.maxWidth,
        minH: constraints?.minHeight,
        maxH: constraints?.maxHeight,
    };

    // Apply custom layout settings
    const finalLayout = { ...defaultLayout, ...layout };

    // Apply default settings from widget definition
    const defaultSettings: WidgetSettings = {};
    if (widgetDefinition) {
        widgetDefinition.configFields.forEach((field) => {
            if (field.defaultValue !== undefined) {
                defaultSettings[field.key] = field.defaultValue;
            }
        });
    }

    // Merge default settings with provided settings
    const finalSettings = { ...defaultSettings, ...settings };

    return {
        id,
        type,
        title,
        layout: finalLayout,
        settings: finalSettings,
        dateAdded: now,
        dateUpdated: now,
    };
}

/**
 * Generates insight widgets based on event data patterns
 */
export function generateInsightWidgets(events: EventData[]): WidgetConfig[] {
    const insights: WidgetConfig[] = [];

    // Only generate insights if we have enough data
    if (events.length < 10) {
        return insights;
    }

    // Example: Detect if there are multiple conversion events
    const conversionEvents = events.filter(
        (e) =>
            e.type && (e.type === "conversion" || e.type.includes("purchase"))
    );
    if (conversionEvents.length >= 3) {
        // Find most common page before conversion
        const pagesBefore = new Map<string, number>();
        let mostCommonPage = "";
        let maxCount = 0;

        conversionEvents.forEach((event) => {
            // Simple heuristic: use previous event's page if available
            const eventIndex = events.findIndex((e) => e.id === event.id);
            if (eventIndex > 0) {
                const prevEvent = events[eventIndex - 1];
                const pagePath =
                    typeof prevEvent.page === "string" ? prevEvent.page : "";
                if (pagePath) {
                    const count = (pagesBefore.get(pagePath) || 0) + 1;
                    pagesBefore.set(pagePath, count);

                    if (count > maxCount) {
                        maxCount = count;
                        mostCommonPage = pagePath;
                    }
                }
            }
        });

        insights.push(
            createWidget("conversionMetrics", "Conversion Metrics", undefined, {
                timeFrame: "30d",
                isAutoGenerated: true,
                insightType: "conversion",
                activatingPage: mostCommonPage || undefined,
                conversionEvent: conversionEvents[0]?.type || "conversion",
            })
        );
    }

    // Example: Detect if there are many referrers
    const referrers = new Set();
    events.forEach((event) => {
        if (event.payload?.referrer) {
            referrers.add(event.payload.referrer);
        }
    });

    if (referrers.size >= 3) {
        insights.push(
            createWidget("topReferrers", "Top Referrers", undefined, {
                timeFrame: "7d",
                isAutoGenerated: true,
                displayOptions: {
                    maxItems: 5,
                    chartType: "pie",
                },
            })
        );
    }

    return insights;
}

/**
 * Analyzes events for correlations and patterns
 */
export function analyzeEventPatterns(events: EventData[]): {
    [key: string]: unknown;
} {
    const patterns: { [key: string]: unknown } = {};

    if (events.length === 0) return patterns;

    // Calculate average events per day
    const dates = events.map((e) => new Date(e.created_at).toDateString());
    const uniqueDates = new Set(dates);
    patterns.averageEventsPerDay =
        events.length / Math.max(1, uniqueDates.size);

    // Calculate most active hours
    const hourCounts: Record<string, number> = {};
    events.forEach((event) => {
        const hour = new Date(event.created_at).getHours();
        hourCounts[hour] = (hourCounts[hour] || 0) + 1;
    });

    const sortedHours = Object.entries(hourCounts)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 3)
        .map(([hour]) => parseInt(hour));

    patterns.mostActiveHours = sortedHours;

    return patterns;
}

const widgetFactory = {
    createWidget,
    generateInsightWidgets,
    analyzeEventPatterns,
};

export default widgetFactory;
